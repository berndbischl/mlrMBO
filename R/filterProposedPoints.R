# tries to sequentially accept proposed points. points which are located too close to design
# points or already accepted proposed points are dropped and replaced by random points.
#
# input:
#   prop  [list] : list of proposed points, as generated by proposePoints
# output  [list] : same format as input, but some points replaced

filterProposedPoints = function(prop, opt.state) {

  opt.problem = getOptStateOptProblem(opt.state)
  opt.path = getOptStateOptPath(opt.state)
  par.set = getOptProblemParSet(opt.problem)
  control = getOptProblemControl(opt.problem)

  # prepare stuff
  n = nrow(prop$prop.points)
  design = getOptPathX(opt.path)
  disc.params = getParamIds(filterParamsDiscrete(par.set), repeated = TRUE, with.nr = TRUE)

  calcDistance = function(pp, design) {
    calcMaxMetric = function(x, y) max(abs(x - y))
    if (length(disc.params) > 0) {
      # if we have discrete params subset the design to match the values of the discrete values in pp then calculate the distance on the numberic subset
      disc.pp = pp[, disc.params, drop = FALSE]
      this.design = merge(design, disc.pp)
      this.design = this.design[, names(this.design) %nin% disc.params, drop = FALSE]
      this.pp = pp[, names(pp) %nin% disc.params, drop = FALSE]
      min.dist = min(apply(this.design, 1L, calcMaxMetric, y = this.pp))
    } else {
      min.dist = min(apply(design, 1L, calcMaxMetric, y = pp))
    }
  }

  for (i in seq_len(n)) {
    pp = prop$prop.points[i, ]
    min.dist = calcDistance(pp, design)
    trial = 0
    # min.dist can be NA for discrete only subspaces
    while (is.na(min.dist) || min.dist < control$filter.proposed.points.tol && trial < 100) {
      pp = generateRandomDesign(1, par.set)[1, ]
      min.dist = calcDistance(pp, design)
      trial = trial + 1
    }
    design = rbind(design, pp)
    if (trial > 0) {
      prop$prop.points[i, ] = pp
      prop$prop.type[i] = "random_filter"
    }
  }

  return(prop)

}
